<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://blog.drogue.io/main.css">

    <title>Firmware updates, part 1: Bootloader &mdash; Drogue IoT</title>

    
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.drogue.io/rss.xml">
    

    
    <style>
        .hero-body {
            padding: 0;
        }
        .header-image {
            width: 100%;
            max-width: unset;

            height: auto;
            min-height: 32px;
            max-height: 33vh !important;

            object-fit: contain;
            object-position: left center;
            background-color: #8cc73f;
        }
    </style>
    <link rel="icon" type="image/svg+xml" href="https://blog.drogue.io/favicon.svg">
    

    <meta name="description" content="This is the first post in a series (part 2, part 3) about doing device firmware updates (DFU) over the air (OTA) and continuous delivery of firmware for embedded devices. We&#x27;ll explore the different parts of a complete end-to-end system with this capability.
This post will be about a fundamental component in such a system: the bootloader.
">


<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@DrogueIoT" />
<meta name="twitter:title" content="Firmware updates, part 1: Bootloader" />
<meta name="twitter:description" content="This is the first post in a series (part 2, part 3) about doing device firmware updates (DFU) over the air (OTA) and continuous delivery of firmware for embedded devices. We&#x27;ll explore the different parts of a complete end-to-end system with this capability.
This post will be about a fundamental component in such a system: the bootloader.
">
<meta name="twitter:image" content='https://blog.drogue.io/default_social_image.png'>


<meta property="og:type" content="article" />
<meta property="og:site_name" content="Drogue IoT">
<meta property="og:title" content="Firmware updates, part 1: Bootloader">
<meta property="og:url" content="https://blog.drogue.io/firmware-updates-part-1">
<meta property="og:description" content="This is the first post in a series (part 2, part 3) about doing device firmware updates (DFU) over the air (OTA) and continuous delivery of firmware for embedded devices. We&#x27;ll explore the different parts of a complete end-to-end system with this capability.
This post will be about a fundamental component in such a system: the bootloader.
">
<meta property="og:image" content='https://blog.drogue.io/default_social_image.png'>


    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QVBDYPJX0S"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-QVBDYPJX0S', { 'anonymize_ip': true });
    </script>
  </head>

<body>

<section class="hero pb-5">
  <div class="hero-body">
    <a href="https://blog.drogue.io">
      <img class="header-image" src="https://blog.drogue.io/header.svg" alt="Header image">
    </a>
  </div>
</section>

<section class="section">
  
  <div class="container is-fluid">
    <div class="columns is-multiline">

      <aside class="column is-one-quarter-fullhd">
      
        <div class="is-sticky">
          <h2 class="title is-2 is-block-fullhd is-skipped">Links</h2>
          <ul class="link-list">
            <li><a href="https://blog.drogue.io">Blog</a></li>
            <li><a href="https:&#x2F;&#x2F;drogue.io" target="_blank">Project Homepage</a></li>
            <li><a href="https:&#x2F;&#x2F;github.com&#x2F;drogue-iot" target="_blank">GitHub Organization</a></li>
            <li><a href="https:&#x2F;&#x2F;book.drogue.io" target="_blank">Documentation</a></li>
            <li><a href="https:&#x2F;&#x2F;matrix.to&#x2F;#&#x2F;#drogue-iot:matrix.org" target="_blank">Community Chat</a></li>
            <li><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UC7GZUy2hKidvY6V_3QZfCcA" target="_blank">YouTube</a></li>
            <li><a href="https:&#x2F;&#x2F;vimeo.com&#x2F;user1825398" target="_blank">Vimeo</a></li>
            <li><a href="https:&#x2F;&#x2F;twitter.com&#x2F;DrogueIoT" target="_blank">Twitter</a></li>
            <li><a href="https:&#x2F;&#x2F;sandbox.drogue.cloud" target="_blank">Sandbox</a></li>
            <li><a href="https:&#x2F;&#x2F;calendar.google.com&#x2F;calendar&#x2F;u&#x2F;0&#x2F;embed?src=ofuctjec399jr6kara7n0uidqg@group.calendar.google.com" target="_blank">Community Calls</a></li>
          </ul>
        </div>
      
      </aside>

      <div class="column is-half-fullhd is-two-thirds-tablet is-three-quarters-desktop is-full">
        
<article itemscope itemtype="http://schema.org/BlogPosting">

  <section class="content">
    <h1 class="title is-size-2" itemprop="name headline">Firmware updates, part 1: Bootloader</h1>
    <div class="subtitle has-text-grey">
    

<div class="post-info">

    <div class="post-info-item">
        <span>15 minute read</span>
        <meta itemprop="wordCount" content="2966">
    </div>

    
        <div class="post-info-item">
            <span itemprop="datePublished" content='2022-04-29'>29 April 2022</span>
        </div>
    

    

    
        <div class="post-info-item">
        <span>by 

<span itemprop="author" itemscope itemtype="http://schema.org/Person">
<span itemprop="name">Ulf Lilleengen</span>
</span>

</span>
        </div>
    

    <div class="post-info-item">
        <span><a href="&#x2F;firmware-updates-part-1&#x2F;#comments">comments</a></span>
    </div>

    

</div>


    </div>
  </section>

  <hr>

  <section class="content post-content" itemprop="articleBody">
    <p>This is the first post in a series (<a href="https://blog.drogue.io/firmware-updates-part-2/">part 2</a>, <a href="https://blog.drogue.io/firmware-updates-part-3">part 3</a>) about doing device firmware updates (DFU) over the air (OTA) and continuous delivery of firmware for embedded devices. We'll explore the different parts of a complete end-to-end system with this capability.</p>
<p>This post will be about a fundamental component in such a system: the bootloader.</p>
<span id="continue-reading"></span><h1 id="background">Background</h1>
<p>For a connected devices to be maintainable at scale, they must be able to update themselves just like any other software. However, managing a fleet of occasionally connected devices with little bandwidth requires a different approach to delivering software updates to regular applications. One goal for Drogue IoT is to support the entire software update workflow on tiny devices, all the way from building your firmware to delivering it to the device, just like any other modern application.</p>
<h1 id="bootloader">Bootloader</h1>
<p>A fundamental component in an updatable system is the ability to boot different versions of an application. Making a generic bootloader is hard, because there is a large number of different possible device configurations. The complexity and size of a bootloader is also determined by its functionality: a bootloader being able to retrieve firmware from a network has a bigger footprint than one that only loads an application from a fixed location in flash.</p>
<p>Since we're focused on IoT, we can assume that our devices have some form of network connectivity, but we do not wish to tie ourselves to any specific connectivity type. </p>
<p>Moreover, for many applications, it's desirable to retrieve the updates while the application is running, which excludes some bootloader designs that do the firmware update within the bootloader. Given some connectivity strategies may be slow, this may result in an exceedingly long time not executing the application itself.</p>
<p>What happens on power failure while updating? With devices installed in hard-to-reach locations, it is important that we can gracefully handle such a scenario and fall back to an existing version and try again. Likewise, should the new application not work properly, we want to allow falling back to the previous version known to work.</p>
<p>Finally, we want to be able to store firmware in external flash, which has potentially different page and transfer sizes than the internal on-chip flash.</p>
<h1 id="introducing-embassy-boot">Introducing embassy-boot</h1>
<p>After thinking about the above requirements and exploring existing bootloaders, we decided to write a bootloader made for <a href="https://embassy.dev/">embassy</a>, with inspiration from other attempts in the Rust community. The goal was to write a bootloader that met both the above requirements and that would benefit the entire Rust embedded community.</p>
<p>The result of that work now lives in <a href="https://github.com/embassy-rs/embassy/tree/master/examples/boot/nrf">embassy-boot</a>. The <code>embassy-boot</code> bootloader is a lightweight bootloader supporting firmware application upgrades in a power-fail-safe way, with trial boots and rollbacks. </p>
<p>The bootloader consists of two parts, a platform independent part and a platform dependent part. The platform independent part is a standard Rust library (and there are unit tests using an in-memory 'flash' for testing correctness) that can be used to build your custom bootloader. The platform-dependent part ties the generic library to a specific hardware platform, such as nRF or STM32. This provides some hardware-specific functionality, for instance integration with nrf-softdevice or a watchdog timer for nRF devices.</p>
<p>NOTE: Do I need to use embassy with <code>embassy-boot</code>? Absolutely not! <code>embassy-boot</code> just happens to use embassy internally for the platform dependent parts. The application side uses async APIs to write firmware (preventing you blocking other tasks while writing firmware to flash), but does not require any specific runtime or HAL, as long as it implements the <code>embedded-storage</code> interface.</p>
<p>The bootloader flash memory is divided into logical areas named <code>Partitions</code>:</p>
<figure>
    <img src="partitions.png" alt="Bootloader partitions" />
    <figcaption>Bootloader partitions</figcaption>
</figure>
<p>Each partition is an area of flash on a microcontroller, but only the <code>Bootloader</code> and <code>Active</code> partitions need to be on the same physical flash storage. This means you can use off-chip flash to store the firmware update if desired.</p>
<p>The <code>Bootloader</code> partition contains the bootloader application itself, usually around 8kB if disabling debug logging. The <code>Bootloader State</code> partition contains a flag indicating if firmware within the <code>Active</code> and <code>DFU</code> partitions should be swapped or not, as well as a progress index used by the swap and revert algorithm.</p>
<p>The <code>Active</code> partition contains the currently running firmware, and the bootloader will always jump to the application at the start of the <code>Active</code>  partition. The <code>DFU</code> partition contains the &quot;next&quot; firmware to be updated, until the update is signaled, at which point the bootloader will gradually swap it with the &quot;old&quot; firmware.</p>
<h2 id="initial-boot">Initial boot</h2>
<p>At initial boot, the bootloader performs the following operations:</p>
<ol>
<li>Read current bootloader state magic word.</li>
<li>If no &quot;SWAP&quot; magic bytes found, boot the current firmware.</li>
<li>If &quot;SWAP&quot; magic bytes found, perform the swap between the Active and DFU firmwares.</li>
<li>Boot the new current firmware.</li>
</ol>
<h2 id="updating-the-firmware">Updating the firmware</h2>
<p>An application that wants to be capable of firmware update will need to create an instance of a <code>FirmwareUpdater</code>. This is provided by the <code>embassy-boot</code> library, with defaults available if using the <code>embassy-boot-nrf</code> or <code>embassy-boot-stm32</code> libraries. The <code>FirmwareUpdater</code> is capable of the following operations:</p>
<ul>
<li>Write firmware to any offset within the <code>DFU</code> partition.</li>
<li>Mark the current running firmware as 'OK', to prevent a firmware rollback.</li>
<li>Mark the current firwmare to be swapped by the new firmware.</li>
</ul>
<p>To create an updater instance with configuration from linker script:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let mut</span><span> updater = FirmwareUpdater::default();
</span></code></pre>
<p>How the firmware gets to the device is not the responsibility of the <code>FirmwareUpdater</code>, which leaves this problem to the application itself. In the next blog post, we will cover different ways you can get the firmware to the device.</p>
<p>To write a firmware block to flash (data must meet the alignment requirements of the flash instance you're providing):</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>updater.</span><span style="color:#96b5b4;">write_firmware</span><span>(offset, &amp;[</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>], &amp;</span><span style="color:#b48ead;">mut</span><span> flash).await
</span></code></pre>
<p>This allows you to write firmware in smaller pieces at a time, which might be necessary for constrainted devices.</p>
<p>Once the new firmware is written, it is marked to be swapped with the current firmware by invoking the <code>update</code> method:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>updater.</span><span style="color:#96b5b4;">update</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> flash).await
</span></code></pre>
<p>Once returned, the application needs to reset the device. Upon reset, the device will enter the bootloader once again, and attempt to swap the firmware before booting the next version.</p>
<p>NOTE: By structuring your application accordingly, you may update the firmware in parallel while running other tasks. This reduces the downtime of your application to a minimum.</p>
<h2 id="swap-algorithm">Swap algorithm</h2>
<p>At the core of the bootloader is the partition swapping algorithm, which is not tied to any specific platform. The algorithm is based on earlier work by Dario Nieuwenhuis (who created the embassy project) and extended so support more configuration. The algorithm keeps an internal state of the copy progress in flash, using 1 word per index value which ensures that only a single erase is needed before starting the swap process, as opposed to erase + write for every index counter update.</p>
<p>Lets assume a flash size of 3 pages for the Active partition, and 4 pages for the DFU partition. The swap index contains the copy progress, as to allow detecting if copy is completed or not on power failure. The index counter is represented within 1 or more pages (depending on total flash size), where a page X is considered swapped if index at location (X + WRITE_SIZE) contains a non-erased value. This ensures that index updates can be performed atomically and avoid a situation where the wrong index value is set (page write size is &quot;atomic&quot;).</p>
<p>The initial state of the Active, DFU and State partitions are shown below:</p>
<figure>
    <img src="swap_initial.png" alt="Initial state" />
    <figcaption>Initial State</figcaption>
</figure>
<p>The <code>State</code> partition is only showing the index for the <code>Active</code> partition for simplicity. The algorithm starts by copying 'backwards', and after the first step, the layout is as follows:</p>
<figure>
    <img src="swap_step1.png" alt="Copy state 1" />
    <figcaption>Copy State 1</figcaption>
</figure>
<p>The next iteration performs the same steps:</p>
<figure>
    <img src="swap_step2.png" alt="Copy state 2" />
    <figcaption>Copy State 2</figcaption>
</figure>
<p>And again until we're done:</p>
<figure>
    <img src="swap_final.png" alt="Final state" />
    <figcaption>Final State</figcaption>
</figure>
<p>The reverting algorithm uses the swap index to check if images were swapped, or that the application failed to mark the boot successful. In this case, the revert algorithm will
run.</p>
<p>The revert index is located separately from the swap index, to ensure that revert can continue on power failure.</p>
<p>Another thing to note is that the revert algorithm works forwards, by copying into the 'unused' DFU page at the start.</p>
<p>Once the swap process is complete, the bootloader may jump to the application at the beginning of the active partition.</p>
<p>This is a platform-specific step done in the <code>embassy-boot-stm32</code> or <code>embassy-boot-nrf</code> part of the bootloader.</p>
<p>NOTE: The new application is responsible for marking itself as successfully booted, otherwise the bootloader will attempt to revert to the previous application when restarted!</p>
<p>The application marks itself as successfully booted by invoking <code>mark_booted</code>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>updater.</span><span style="color:#96b5b4;">mark_booted</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> flash).await
</span></code></pre>
<h3 id="power-fail-safety">Power fail safety</h3>
<p>What happens if the swap process is interrupted during the copy? Can we still revert back to the old version in a half-copied state? Yes! After a power failure, the device may be in one of the following states during the update process:</p>
<ul>
<li>Firmware has been written, but not instructed to update. In this case, no action is taken and the old firmware will be used.</li>
<li>Should swap, but swap is not complete. In this case, the bootloader will continue the swap operation from where it left off. The crucial step in this process is that the page copy progress state is written atomically.</li>
<li>Swap is complete, but is still instructed to update. In this case, the bootloader will assume that something went wrong with the new application and will start to revert to the previous application.</li>
<li>Should revert, but revert is not complete. Similar to the previous state, the revert process will continue where it left off until complete.</li>
</ul>
<h2 id="rolling-back">Rolling back</h2>
<p>So your application got updated, but you had a bug in your application causing it to crash! Now what? Well, there are a few key principles that should be met within your application to ensure that you don't get 'stuck'. On a reset, the bootloader will take care of swapping back the existing firmware, so make sure that:</p>
<ul>
<li>In the event of an unrecoverable error, panic! Make sure you use a panic handler that allows your device to reset and start over (causing the bootloader to roll back).</li>
<li>Your application is running correctly before marking itself as successfully booted. Doing this too early could cause your application to be stuck with the new faulty firmware.</li>
</ul>
<p>For IoT connected devices, there is an additional trick: make sure you can connect to the required services (such as the firmware update service) before marking the firmware as successfully booted. This increases the chance you will be able to recover and fix bugs by rolling out a new version of your firmware. We'll cover this in future blog posts of this series.</p>
<h2 id="bootloader-and-application-binaries">Bootloader and application binaries</h2>
<p>The bootloader may be used as a library or as a standalone binary. In the case where it's used as a standalone binary, it must be compiled with the linker script setting the partition boundaries. If you require a high degree of customization, you can use it as a library and provide the partitions programatically.</p>
<p>The application binary can depend on the platform dependent bootloader library for convenience, which will also use the linker script to derive the partition boundaries. In the same way as for making a customized bootloader, you can define the partition boundaries programatically for your application as well.</p>
<p>A typical dependency graph of an application <code>myapp</code> using <code>embassy-boot</code> is shown below:</p>
<figure>
    <img src="dependencies.png" alt="Bootloader dependencies" />
    <figcaption>Bootloader Dependencies</figcaption>
</figure>
<h3 id="application-linker-script">Application linker script</h3>
<p>The linker script defines the partition boundaries. It is only needed if you don't want to define the partition limits in code. A linker script may look like this for an nRF52 application:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>MEMORY
</span><span>{
</span><span>  /* NOTE 1 K = 1 KiBi = 1024 bytes */
</span><span>  BOOTLOADER                        : ORIGIN = 0x00000000, LENGTH = 24K
</span><span>  BOOTLOADER_STATE                  : ORIGIN = 0x00006000, LENGTH = 4K
</span><span>  FLASH                             : ORIGIN = 0x00007000, LENGTH = 64K
</span><span>  DFU                               : ORIGIN = 0x00017000, LENGTH = 68K
</span><span>  RAM                         (rwx) : ORIGIN = 0x20000008, LENGTH = 32K
</span><span>}
</span><span>
</span><span>__bootloader_state_start = ORIGIN(BOOTLOADER_STATE);
</span><span>__bootloader_state_end = ORIGIN(BOOTLOADER_STATE) + LENGTH(BOOTLOADER_STATE);
</span><span>
</span><span>__bootloader_dfu_start = ORIGIN(DFU);
</span><span>__bootloader_dfu_end = ORIGIN(DFU) + LENGTH(DFU);
</span></code></pre>
<p>The BOOTLOADER section is not strictly necessary but shown for documentation purposes. The locations starting with <code>__bootloader*</code> are read by the <code>FirmwareUpdater</code> default initialization code to learn the partition limits. Note that the <code>Active</code> partition is not known by the <code>FirmwareUpdater</code> but is effectively the <code>FLASH</code> region as defined in the above linker script.</p>
<h3 id="bootloader-binary">Bootloader binary</h3>
<p>The bootloader binary itself is only concerned with initializing peripherals and the bootloader before loading the application. </p>
<p>The standard out of the box bootloader application looks like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">entry</span><span>]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() -&gt; ! {
</span><span>    </span><span style="color:#65737e;">// Initialize the peripherals
</span><span>    </span><span style="color:#b48ead;">let</span><span> p = embassy_nrf::init(Default::default());
</span><span>    
</span><span>    </span><span style="color:#65737e;">// Setup flash used to store firmware
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> flash = Nvmc::new(p.</span><span style="color:#d08770;">NVMC</span><span>);
</span><span>
</span><span>    </span><span style="color:#65737e;">// Create bootloader using partition limits derived from linker script
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> bl: BootLoader = BootLoader::default();
</span><span>    
</span><span>    </span><span style="color:#65737e;">// Prepare the bootloader for launching the application, performs necessary swap or rollback operation depending on the internal state.
</span><span>    </span><span style="color:#65737e;">// You can provide your own FlashProvider implementation if you want to use separate flash for Active, DFU and State partitions.
</span><span>    </span><span style="color:#b48ead;">let</span><span> start = bl.</span><span style="color:#96b5b4;">prepare</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span>SingleFlashProvider::new(&amp;</span><span style="color:#b48ead;">mut</span><span> flash));
</span><span>
</span><span>    </span><span style="color:#65737e;">// Ensures flash is dropped again before launching application
</span><span>    core::mem::drop(flash);
</span><span>    
</span><span>    </span><span style="color:#65737e;">// Load application (fingers crossed)
</span><span>    </span><span style="color:#b48ead;">unsafe </span><span>{ bl.</span><span style="color:#96b5b4;">load</span><span>(start) }
</span><span>}
</span></code></pre>
<h3 id="bootloader-linker-script">Bootloader linker script</h3>
<p>The linker script defines the partition boundaries. It is only needed if you don't want to write your own bootloader binary. A linker script may look like this for an nRF52 application:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>MEMORY
</span><span>{
</span><span>  /* NOTE 1 K = 1 KiBi = 1024 bytes */
</span><span>  FLASH                             : ORIGIN = 0x00000000, LENGTH = 24K
</span><span>  BOOTLOADER_STATE                  : ORIGIN = 0x00006000, LENGTH = 4K
</span><span>  ACTIVE                            : ORIGIN = 0x00007000, LENGTH = 64K
</span><span>  DFU                               : ORIGIN = 0x00017000, LENGTH = 68K
</span><span>  RAM                         (rwx) : ORIGIN = 0x20000008, LENGTH = 32K
</span><span>}
</span><span>
</span><span>__bootloader_state_start = ORIGIN(BOOTLOADER_STATE);
</span><span>__bootloader_state_end = ORIGIN(BOOTLOADER_STATE) + LENGTH(BOOTLOADER_STATE);
</span><span>
</span><span>__bootloader_active_start = ORIGIN(ACTIVE);
</span><span>__bootloader_active_end = ORIGIN(ACTIVE) + LENGTH(ACTIVE);
</span><span>
</span><span>__bootloader_dfu_start = ORIGIN(DFU);
</span><span>__bootloader_dfu_end = ORIGIN(DFU) + LENGTH(DFU);
</span></code></pre>
<p>The difference to the application linker script is minimal. The <code>FLASH</code> region is now in the bootloader region. The <code>Active</code> partition boundaries are also required to be known by the bootloader.</p>
<h2 id="portability">Portability</h2>
<p>As we've seen above, only a small amount of code is required to write your own bootloader using <code>embassy-boot</code>. Extending to new hardware platforms within the STM32 family requires adding a working flash driver for that chip, at which point the <code>embassy-boot-stm32</code> library should work with that particular family. For different chip vendors and architectures like RISC-V, creating another <code>embassy-boot-riscv</code> would be needed, but still the amount of hardware-specific code should only be related to setting up peripherals and providing the correct boot process for that hardware.</p>
<h2 id="examples">Examples</h2>
<p>To get started using <code>embassy-boot</code>, you can find ready-made examples in <a href="https://github.com/embassy-rs/embassy/tree/master/examples/boot">embassy</a> for several chips. If you have a board that is not listed, reach out in the <a href="https://matrix.to/#/#embassy-rs:matrix.org">embassy chat</a> or contribute an example yourself.</p>
<p>We also have a demonstrating the use of <code>embassy-boot</code> and the swap + rollback logic:</p>
<p><a href="https://youtu.be/3QkA58GObJU"><img src="https://img.youtube.com/vi/3QkA58GObJU/0.jpg" alt="Firmware updates" /></a></p>
<h2 id="alternatives">Alternatives</h2>
<p>There are many existing bootloaders, like <a href="https://www.mcuboot.com/">mcuboot</a>, which probably has the best device and feature support. However, building and running a C based bootloader and adapting it to work with <code>embassy</code> is also not as nice as using Rust tooling and being able to reuse the hardware support already in embassy. </p>
<p>Another bootloader with a similar approach to <code>embassy-boot</code> is <a href="https://jhbruhn.de/posts/moonboot/">moonboot</a>, which shares a similar design with a split responsibility between the bootloader and application but is even more generic (not tied to embassy, but also means more work to use) and (at the time of writing) not power fail safe. Clearly there is an opportunity for collaboration in the future.</p>
<p>UPDATE: An alternative to using a swap algorithm could be to have two active partitions, and have the bootloader switch between loading each of them. However, this would require using different linker scripts depending on which partition you wanted to use, because Rust does not yet support position independent code.</p>
<h1 id="future-work">Future work</h1>
<ul>
<li>Adding support for more hardware platforms. At present, the nRF52 and STM32 platforms are supported, but not all STM32 families have a working flash driver. Supporting hardware like the Raspberry Pi Pico is also on the wish list.</li>
<li>Firmware verification. Being able to install a trusted public key in the bootloader that can be used to verify a firmware signature before swapping/booting.</li>
<li>Additional bootloader capabilities such as having a fail safe partition with 'factory settings' in case reverting fail.</li>
</ul>
<h1 id="summary">Summary</h1>
<p>In this first post in a series, we have looked at the fundamental microcontroller component required to support firmware updates. We first had a look at the features required from a bootloader, and then had a look at the newly created <code>embassy-boot</code>and learned how it swaps firmware. Finally we've discussed what it means to be power safe and how <code>embassy-boot</code> ensures that application updates are reliable, with some delegation of that responsibility of the application to mark itself as 'OK'.</p>
<p>In the next <a href="https://blog.drogue.io/firmware-updates-part-2/">blog post</a>, we will have a look at different mechanisms for getting the firmware onto the device itself.</p>

  </section>

</article>

    </div>

    <aside class="column is-hidden-mobile is-one-third-tablet is-one-quarter-desktop">
      
<div class="box is-sticky ml-5">
  <div class="title is-size-3"><a href="#">Table of contents</a></div>
  <nav class="menu">
    <ul class="menu-list">
      
      <li>
        <a data-for="background" href="https://blog.drogue.io/firmware-updates-part-1/#background">Background</a>
        
      </li>
      
      <li>
        <a data-for="bootloader" href="https://blog.drogue.io/firmware-updates-part-1/#bootloader">Bootloader</a>
        
      </li>
      
      <li>
        <a data-for="introducing-embassy-boot" href="https://blog.drogue.io/firmware-updates-part-1/#introducing-embassy-boot">Introducing embassy-boot</a>
        
        <ul class="menu-list">
          
          <li>
            <a data-for="initial-boot" href="https://blog.drogue.io/firmware-updates-part-1/#initial-boot">Initial boot</a>
          </li>
          
          <li>
            <a data-for="updating-the-firmware" href="https://blog.drogue.io/firmware-updates-part-1/#updating-the-firmware">Updating the firmware</a>
          </li>
          
          <li>
            <a data-for="swap-algorithm" href="https://blog.drogue.io/firmware-updates-part-1/#swap-algorithm">Swap algorithm</a>
          </li>
          
          <li>
            <a data-for="rolling-back" href="https://blog.drogue.io/firmware-updates-part-1/#rolling-back">Rolling back</a>
          </li>
          
          <li>
            <a data-for="bootloader-and-application-binaries" href="https://blog.drogue.io/firmware-updates-part-1/#bootloader-and-application-binaries">Bootloader and application binaries</a>
          </li>
          
          <li>
            <a data-for="portability" href="https://blog.drogue.io/firmware-updates-part-1/#portability">Portability</a>
          </li>
          
          <li>
            <a data-for="examples" href="https://blog.drogue.io/firmware-updates-part-1/#examples">Examples</a>
          </li>
          
          <li>
            <a data-for="alternatives" href="https://blog.drogue.io/firmware-updates-part-1/#alternatives">Alternatives</a>
          </li>
          
        </ul>
        
      </li>
      
      <li>
        <a data-for="future-work" href="https://blog.drogue.io/firmware-updates-part-1/#future-work">Future work</a>
        
      </li>
      
      <li>
        <a data-for="summary" href="https://blog.drogue.io/firmware-updates-part-1/#summary">Summary</a>
        
      </li>
      
    </ul>
  </nav>
</div>

    </aside>

    </div>
  </div>

  
</section>

<footer class="footer">
  <div class="content has-text-centered">
    <p>
      <strong>Drogue IoT</strong>
  </div>
</footer>

<script src="https://blog.drogue.io/default.js"></script>

</body>

</html>
