<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://blog.drogue.io/main.css">

    <title>More Rust &amp; Async (and hand-rolled PWM) &mdash; Drogue IoT</title>

    
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.drogue.io/rss.xml">
    

    
    <style>
        .hero-body {
            padding: 0;
        }
        .header-image {
            width: 100%;
            max-width: unset;

            height: auto;
            min-height: 32px;
            max-height: 33vh !important;

            object-fit: contain;
            object-position: left center;
            background-color: #8cc73f;
        }
    </style>
    <link rel="icon" type="image/svg+xml" href="https://blog.drogue.io/favicon.svg">
    

    <meta name="description" content="Improvements to an async embedded kernel for Rust">


<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@DrogueIoT" />
<meta name="twitter:title" content="More Rust &amp; Async (and hand-rolled PWM)" />
<meta name="twitter:description" content="Improvements to an async embedded kernel for Rust">
<meta name="twitter:image" content='https://blog.drogue.io/default_social_image.png'>


<meta property="og:type" content="article" />
<meta property="og:site_name" content="Drogue IoT">
<meta property="og:title" content="More Rust &amp; Async (and hand-rolled PWM)">
<meta property="og:url" content="https://blog.drogue.io/more-async-and-pwm">
<meta property="og:description" content="Improvements to an async embedded kernel for Rust">
<meta property="og:image" content='https://blog.drogue.io/default_social_image.png'>


    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QVBDYPJX0S"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-QVBDYPJX0S', { 'anonymize_ip': true });
    </script>
  </head>

<body>

<section class="hero pb-5">
  <div class="hero-body">
    <a href="https://blog.drogue.io">
      <img class="header-image" src="https://blog.drogue.io/header.svg" alt="Header image">
    </a>
  </div>
</section>

<section class="section">
  
  <div class="container is-fluid">
    <div class="columns is-multiline">

      <aside class="column is-one-quarter-fullhd">
      
        <div class="is-sticky">
          <h2 class="title is-2 is-block-fullhd is-skipped">Links</h2>
          <ul class="link-list">
            <li><a href="https://blog.drogue.io">Blog</a></li>
            <li><a href="https:&#x2F;&#x2F;drogue.io" target="_blank">Project Homepage</a></li>
            <li><a href="https:&#x2F;&#x2F;github.com&#x2F;drogue-iot" target="_blank">GitHub Organization</a></li>
            <li><a href="https:&#x2F;&#x2F;book.drogue.io" target="_blank">Documentation</a></li>
            <li><a href="https:&#x2F;&#x2F;matrix.to&#x2F;#&#x2F;#drogue-iot:matrix.org" target="_blank">Community Chat</a></li>
            <li><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UC7GZUy2hKidvY6V_3QZfCcA" target="_blank">YouTube</a></li>
            <li><a href="https:&#x2F;&#x2F;vimeo.com&#x2F;user1825398" target="_blank">Vimeo</a></li>
            <li><a href="https:&#x2F;&#x2F;twitter.com&#x2F;DrogueIoT" target="_blank">Twitter</a></li>
            <li><a href="https:&#x2F;&#x2F;sandbox.drogue.cloud" target="_blank">Sandbox</a></li>
            <li><a href="https:&#x2F;&#x2F;calendar.google.com&#x2F;calendar&#x2F;u&#x2F;0&#x2F;embed?src=ofuctjec399jr6kara7n0uidqg@group.calendar.google.com" target="_blank">Community Calls</a></li>
          </ul>
        </div>
      
      </aside>

      <div class="column is-half-fullhd is-two-thirds-tablet is-three-quarters-desktop is-full">
        
<article itemscope itemtype="http://schema.org/BlogPosting">

  <section class="content">
    <h1 class="title is-size-2" itemprop="name headline">More Rust &amp; Async (and hand-rolled PWM)</h1>
    <div class="subtitle has-text-grey">
    

<div class="post-info">

    <div class="post-info-item">
        <span>6 minute read</span>
        <meta itemprop="wordCount" content="1183">
    </div>

    
        <div class="post-info-item">
            <span itemprop="datePublished" content='2020-12-15'>15 December 2020</span>
        </div>
    

    

    
        <div class="post-info-item">
        <span>by 

<span itemprop="author" itemscope itemtype="http://schema.org/Person">
<span itemprop="name">Bob McWhirter</span>
</span>

</span>
        </div>
    

    <div class="post-info-item">
        <span><a href="&#x2F;more-async-and-pwm&#x2F;#comments">comments</a></span>
    </div>

    

</div>


    </div>
  </section>

  <hr>

  <section class="content post-content" itemprop="articleBody">
    <p>If we start living the async lifestyle, we can potentially get more
use out of our limited hardware resources.  Maybe not, but it's worth
exploring. Let's explore.</p>
<span id="continue-reading"></span><h1 id="embedded-rtos-oses-and-frameworks">Embedded, RTOS, OSes and Frameworks</h1>
<p>First, let's all agree we're doing embedded work on bare chips, where we
can pretty freely twiddle any register we want. In the Rust world, this
would be called <em>bare metal</em> development.</p>
<p>Take a step upwards, and you've got a framework such as RTIC, which provides
facilities to make writing functional embedded code easier, while also
making it easier to organize your code and reason over it.</p>
<p>A step beyond that would be something like Zephyr, Tock, Drone or another
RTOS (real-time operating system). RTOSes can be further differentiated into
&quot;hard&quot; real-time (hey, airbag needs to absolutely fire within 15 nano-seconds
of impact) or &quot;soft&quot; real-time, which relaxes the timing requirements.</p>
<p>Beyond that, you get to a more general-purpose OS, which may or may not
include things like network drivers and other facilities we've come to
love on our machines running BeOS or OS/2 Warp (or, I guess, Linux).</p>
<p>In general, all of the above, from an embedded point-of-view, provide basically:</p>
<ul>
<li>Ways to run tasks</li>
<li>Ways to handle interrupts</li>
<li>Misc useful capabilities used by the above</li>
</ul>
<h2 id="an-async-opportunity">An <code>async</code> opportunity</h2>
<p>I have to admit I'm smitten with <code>async</code> and <code>await</code> on Rust. It just works
the way my mind does. I also have to admit that I've repeated told my boss
&quot;no, dude, we're not writing an RTOS&quot; (Hi, Mark). Then again, I also must admit that my
employer tends to write tools and frameworks for application developers, along
with OSes, so I don't think I'm coloring too far outside the lines in exploring
an async-centric embedded kernel.</p>
<p>Instead of trying to make Linux (or something that feels Linux-like) fit onto
a small board, what if we built an &quot;OS&quot; (but we're not calling it that) from 
the foundations based upon a modern and safe language (Rust) using modern and
efficient idioms (async/reactive)?</p>
<p>But let's just call it a <em>framework</em>.</p>
<h1 id="what-would-it-look-like">What would it look like?</h1>
<p>This week, it looks like the following:</p>
<h2 id="ways-to-run-tasks">Ways to run tasks</h2>
<p>We touched on this in the <a href="/rust-and-async/">last blog post</a> I wrote, but it's simply <code>spawn</code>ing
async Rust tasks, probably containing a loop.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>Kernel::spawn(&quot;</span><span style="color:#a3be8c;">ld2</span><span>&quot;, async </span><span style="color:#b48ead;">move </span><span>{
</span><span>    </span><span style="color:#b48ead;">loop </span><span>{
</span><span>        </span><span style="color:#65737e;">// do awesome stuff
</span><span>    }
</span><span>});
</span></code></pre>
<h2 id="ways-to-handle-interrupts">Ways to handle interrupts</h2>
<p>Here we venture somewhat outside of the &quot;real-time&quot; aspect of RTOSes, which I think
is okay, depending on your use-case. Some operating systems attempt to limit the
work you actually do within an ISR (interrupt service routine), and rather use an
interrupt to wake up a normal &quot;user-land&quot; task that is blocked waiting for its
interrupt to fire.</p>
<p>In my current sketching, I have an API that takes a <em>non async closure</em>, but behind
the scenes wraps it in an async task with a <em>wait for my interrupt</em> and a loop.</p>
<h3 id="the-visible-api">The visible API</h3>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>Kernel::interrupt(</span><span style="color:#d08770;">EXTI15_10</span><span>, </span><span style="color:#b48ead;">move </span><span>|| {
</span><span>    </span><span style="color:#b48ead;">if</span><span> pc13.</span><span style="color:#96b5b4;">check_interrupt</span><span>() {
</span><span>        </span><span style="color:#b48ead;">if</span><span> pc13.</span><span style="color:#96b5b4;">is_low</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>() {
</span><span>            log::info!(&quot;</span><span style="color:#a3be8c;">button pushed</span><span>&quot;);
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            log::info!(&quot;</span><span style="color:#a3be8c;">button released</span><span>&quot;);
</span><span>        }
</span><span>        pc13.</span><span style="color:#96b5b4;">clear_interrupt_pending_bit</span><span>();
</span><span>    }
</span><span>});
</span></code></pre>
<h3 id="the-internal-magic">The internal magic</h3>
<p>It uses the same <code>Kernel::spawn(...)</code> as non-interrupt tasks, along with my
<code>async</code>-capable <code>interrupt(...)</code> API which provides a <code>Future</code> which satisfies
when the associated IRQ is pending.</p>
<p>Then it just calls the passed in closure.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">interrupt</span><span>&lt;N: Nr + Debug + Copy + </span><span style="color:#b48ead;">&#39;static</span><span>, F&gt;(</span><span style="color:#bf616a;">irq</span><span>: N, </span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">isr</span><span>: F) -&gt; Result&lt;(), SpawnError&gt;
</span><span>        </span><span style="color:#b48ead;">where</span><span> F: FnMut() -&gt; () + </span><span style="color:#b48ead;">&#39;static</span><span>,
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> name = String::&lt;U16&gt;::new();
</span><span>        write!(name, &quot;</span><span style="color:#d08770;">{:?}</span><span>&quot;, irq);
</span><span>        </span><span style="color:#b48ead;">Self</span><span>::spawn(name.</span><span style="color:#96b5b4;">as_str</span><span>(), async </span><span style="color:#b48ead;">move </span><span>{
</span><span>            </span><span style="color:#b48ead;">loop </span><span>{
</span><span>                interrupt::interrupt(irq).await;
</span><span>                </span><span style="color:#96b5b4;">isr</span><span>();
</span><span>            }
</span><span>        }).</span><span style="color:#96b5b4;">map</span><span>(|_| ())
</span><span>    }
</span></code></pre>
<h1 id="using-the-resources-and-organizing-code">Using the Resources and Organizing Code</h1>
<p>My example application running on this board uses a single timer to make two LEDs
&quot;breathe&quot; in a non-synchronized manner. You can absolutely re-create this without
using <code>async</code> tasks, but you will be managing a shared interrupt across two <em>users</em>
of that interrupt (the LEDs themselves).</p>
<p>This is a very contrived example of using a timer to manually create a poor-man's
PWM output, but it seemed like a useful challenge to attempt.</p>
<h2 id="quick-aside-pwm">Quick Aside: PWM</h2>
<p>PWM stands for Pulse-Wave Modulation, which in this case means taking a thing that
is either strictly <em>on</em> or <em>off</em> (the LED), and flipping it on and off fast enough 
to appear that it's at 0 to 100% brightness, on a continuum. The human eye will see
an LED that is on 50% of the time and off 50% of the time as about half as bright
as a fully-on LED. If we flip the switch fast enough, it looks &quot;dim&quot;, and not flickery.
(Which, coincidently is why slo-mo video under LEDs looks very blinky blinky).</p>
<h3 id="end-of-aside">&lt;/End of Aside&gt;</h3>
<p>Since we're talking about flipping an LED on/off on some sort of regular schedule,
that's where the timer is involved. Managing one timer and one LED is &quot;easy&quot; for small
values of &quot;easy&quot;, but using a single timer for multiple LEDs could be more of a challenge
if you're directly handling the timer's <em>timeout</em> interrupts. So you might be tempted
to use a timer per LED. Until you run out of timers.</p>
<p>With <code>async</code>, we can quite easily manage multiple LEDs from a single timer. With
my exploratory kernel, we don't have to think about interrupts, but rather only
tasks.</p>
<p>Don't judge my math, but basically we spawn two tasks that look identical (modulo
an initial delay), which runs a <code>duty_cycle</code> from 1 to 99 and back, repeatedly.</p>
<p>At each step, the LED is on for roughly <code>duty_cycle</code> microseconds, and off for <code>100 - duty_cycle</code>
microseconds. For visual appearances, each time is multiplied by <code>20</code> in this case,
and we linger on each step for 4 iterations of a loop. Then we adjust <code>duty_cycle</code>
and do it again, turning around when we reach 99 or 1, back and forth, back and forth.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    Kernel::spawn(&quot;</span><span style="color:#a3be8c;">ld2</span><span>&quot;, async </span><span style="color:#b48ead;">move </span><span>{
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> duty_cycle = </span><span style="color:#d08770;">1</span><span>;
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> up = </span><span style="color:#d08770;">true</span><span>;
</span><span>        </span><span style="color:#b48ead;">let</span><span> dwell = </span><span style="color:#d08770;">4</span><span>;
</span><span>        </span><span style="color:#b48ead;">let</span><span> mult = </span><span style="color:#d08770;">20</span><span>;
</span><span>
</span><span>	</span><span style="color:#65737e;">// the other task does not have this initial 1sec delay
</span><span>        AsyncTimer::delay_ms( Milliseconds(</span><span style="color:#d08770;">1000</span><span style="color:#b48ead;">u32</span><span>)).await;
</span><span>
</span><span>        </span><span style="color:#b48ead;">loop </span><span>{
</span><span>            </span><span style="color:#b48ead;">for </span><span>_ in </span><span style="color:#d08770;">0</span><span>..dwell {
</span><span>                </span><span style="color:#b48ead;">let</span><span> on: </span><span style="color:#b48ead;">u32 </span><span>= (duty_cycle * mult) as </span><span style="color:#b48ead;">u32</span><span>;
</span><span>                </span><span style="color:#b48ead;">let</span><span> off: </span><span style="color:#b48ead;">u32 </span><span>= ((</span><span style="color:#d08770;">100 </span><span>- duty_cycle) * mult) as </span><span style="color:#b48ead;">u32</span><span>;
</span><span>                ld2.</span><span style="color:#96b5b4;">set_high</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>                AsyncTimer::delay_us(Microseconds(on)).await;
</span><span>                ld2.</span><span style="color:#96b5b4;">set_low</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>                AsyncTimer::delay_us(Microseconds(off)).await;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#b48ead;">if</span><span> duty_cycle == </span><span style="color:#d08770;">99 </span><span>{
</span><span>                up = </span><span style="color:#d08770;">false
</span><span>            } </span><span style="color:#b48ead;">else if</span><span> duty_cycle == </span><span style="color:#d08770;">1 </span><span>{
</span><span>                up = </span><span style="color:#d08770;">true</span><span>;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#b48ead;">if</span><span> up {
</span><span>                duty_cycle += </span><span style="color:#d08770;">1
</span><span>            } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                duty_cycle -= </span><span style="color:#d08770;">1</span><span>;
</span><span>            }
</span><span>        }
</span><span>    });
</span></code></pre>
<div class="video >">
  <iframe style="height: 480px; width: 100%;" frameborder="0" src="//player.vimeo.com/video/491304511" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
</div>
<p>As many tasks as we like can conceivably use the singular <code>AsyncTimer</code> which
is currently linked to exactly one timer (<code>TIM15</code> here). Each task
only has to focus on the logic of waiting, turning on, waiting, turning off,
and can ignore the fact that <code>TIM15</code> interrupts are firing.</p>
<h1 id="conclusion">Conclusion</h1>
<p>I like where this is going. I think the next steps might be to help isolate
a task's state into an <em>actor</em> framework using <code>async</code>, and providing a
message-passing way for them to safely communicate.</p>
<p>Plus, I got to try out my new desktop tripod for phone videos. So that's a win.</p>

  </section>

</article>

    </div>

    <aside class="column is-hidden-mobile is-one-third-tablet is-one-quarter-desktop">
      
<div class="box is-sticky ml-5">
  <div class="title is-size-3"><a href="#">Table of contents</a></div>
  <nav class="menu">
    <ul class="menu-list">
      
      <li>
        <a data-for="embedded-rtos-oses-and-frameworks" href="https://blog.drogue.io/more-async-and-pwm/#embedded-rtos-oses-and-frameworks">Embedded, RTOS, OSes and Frameworks</a>
        
        <ul class="menu-list">
          
          <li>
            <a data-for="an-async-opportunity" href="https://blog.drogue.io/more-async-and-pwm/#an-async-opportunity">An async opportunity</a>
          </li>
          
        </ul>
        
      </li>
      
      <li>
        <a data-for="what-would-it-look-like" href="https://blog.drogue.io/more-async-and-pwm/#what-would-it-look-like">What would it look like?</a>
        
        <ul class="menu-list">
          
          <li>
            <a data-for="ways-to-run-tasks" href="https://blog.drogue.io/more-async-and-pwm/#ways-to-run-tasks">Ways to run tasks</a>
          </li>
          
          <li>
            <a data-for="ways-to-handle-interrupts" href="https://blog.drogue.io/more-async-and-pwm/#ways-to-handle-interrupts">Ways to handle interrupts</a>
          </li>
          
        </ul>
        
      </li>
      
      <li>
        <a data-for="using-the-resources-and-organizing-code" href="https://blog.drogue.io/more-async-and-pwm/#using-the-resources-and-organizing-code">Using the Resources and Organizing Code</a>
        
        <ul class="menu-list">
          
          <li>
            <a data-for="quick-aside-pwm" href="https://blog.drogue.io/more-async-and-pwm/#quick-aside-pwm">Quick Aside: PWM</a>
          </li>
          
        </ul>
        
      </li>
      
      <li>
        <a data-for="conclusion" href="https://blog.drogue.io/more-async-and-pwm/#conclusion">Conclusion</a>
        
      </li>
      
    </ul>
  </nav>
</div>

    </aside>

    </div>
  </div>

  
</section>

<footer class="footer">
  <div class="content has-text-centered">
    <p>
      <strong>Drogue IoT</strong>
  </div>
</footer>

<script src="https://blog.drogue.io/default.js"></script>

</body>

</html>
